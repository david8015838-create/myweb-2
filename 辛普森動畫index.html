<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simpsons Night Scene with TV Static</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/framer-motion@10.16.4/dist/framer-motion.js"></script>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Inter', sans-serif; }
        #canvas-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; }
        .ui-overlay { position: relative; z-index: 20; pointer-events: none; }
        .interactive { pointer-events: auto; }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        const { motion, AnimatePresence } = window.Motion;

        const App = () => {
            const [isZoomed, setIsZoomed] = useState(false);
            const sceneRef = useRef(null);

            useEffect(() => {
                window.addEventListener('message', (ev) => {
                    if (ev.data === 'start-simpson') {
                        triggerZoom();
                    }
                });
                
                // --- Three.js 初始化 ---
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x1A1B4B); // 深色夜晚背景

                const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(22, 12, 24);
                camera.lookAt(0, 1.5, 0);

                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                document.getElementById('canvas-container').appendChild(renderer.domElement);

                // --- 雜訊紋理生成 (TV Static) ---
                const noiseCanvas = document.createElement('canvas');
                noiseCanvas.width = 256;
                noiseCanvas.height = 256;
                const noiseCtx = noiseCanvas.getContext('2d');
                const noiseTexture = new THREE.CanvasTexture(noiseCanvas);
                
                const updateNoise = () => {
                    const idata = noiseCtx.createImageData(noiseCanvas.width, noiseCanvas.height);
                    const buffer = new Uint32Array(idata.data.buffer);
                    for (let i = 0; i < buffer.length; i++) {
                        const gray = Math.floor(Math.random() * 255);
                        buffer[i] = (255 << 24) | (gray << 16) | (gray << 8) | gray;
                    }
                    noiseCtx.putImageData(idata, 0, 0);
                    noiseTexture.needsUpdate = true;
                };

                // --- 燈光設定 ---
                const ambientLight = new THREE.AmbientLight(0x4040ff, 0.15);
                scene.add(ambientLight);

                const tvLight = new THREE.PointLight(0x88ccff, 2, 20);
                tvLight.position.set(0, 3, -4);
                scene.add(tvLight);

                const cornerLight = new THREE.PointLight(0xffaa44, 0.3, 30);
                cornerLight.position.set(10, 8, 10);
                scene.add(cornerLight);

                // --- 1. 地板 ---
                const floor = new THREE.Mesh(
                    new THREE.PlaneGeometry(60, 60),
                    new THREE.MeshStandardMaterial({ color: 0x221105 })
                );
                floor.rotation.x = -Math.PI / 2;
                scene.add(floor);

                // --- 2. 沙發 ---
                const sofaGroup = new THREE.Group();
                const sofaMat = new THREE.MeshStandardMaterial({ color: 0x4A2E1F });
                const sofaBase = new THREE.Mesh(new THREE.BoxGeometry(8, 1.2, 3), sofaMat);
                sofaBase.position.y = 0.6;
                const sofaBack = new THREE.Mesh(new THREE.BoxGeometry(8, 2.5, 0.8), sofaMat);
                sofaBack.position.set(0, 1.8, 1.1); 
                const armL = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.8, 3, 16), sofaMat);
                armL.rotation.x = Math.PI / 2;
                armL.position.set(-3.6, 0.8, 0);
                const armR = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.8, 3, 16), sofaMat);
                armR.rotation.x = Math.PI / 2;
                armR.position.set(3.6, 0.8, 0);
                sofaGroup.add(sofaBase, sofaBack, armL, armR);
                sofaGroup.position.set(0, 0, 7); 
                scene.add(sofaGroup);

                // --- 3. 荷馬 ---
                const homer = new THREE.Group();
                const skinMat = new THREE.MeshStandardMaterial({ color: 0xD4B600 });
                const shirtMat = new THREE.MeshStandardMaterial({ color: 0xAAAAAA });
                const pantsMat = new THREE.MeshStandardMaterial({ color: 0x1A2A4A });
                const muzzleMat = new THREE.MeshStandardMaterial({ color: 0x8D785D });
                const hBody = new THREE.Mesh(new THREE.SphereGeometry(0.8, 16, 16), shirtMat);
                hBody.scale.y = 1.2;
                hBody.position.y = 1.8;
                const hHead = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 1, 16), skinMat);
                hHead.position.y = 2.8;
                const hMuzzle = new THREE.Mesh(new THREE.SphereGeometry(0.35, 12, 12), muzzleMat);
                hMuzzle.position.set(0, 2.6, -0.2); 
                const hEyes = new THREE.Group();
                const eyeGeo = new THREE.SphereGeometry(0.12, 8, 8);
                const eyeL = new THREE.Mesh(eyeGeo, new THREE.MeshBasicMaterial({color: 0xffffff}));
                eyeL.position.set(-0.15, 2.9, -0.35);
                const eyeR = new THREE.Mesh(eyeGeo, new THREE.MeshBasicMaterial({color: 0xffffff}));
                eyeR.position.set(0.15, 2.9, -0.35);
                hEyes.add(eyeL, eyeR);
                const hPants = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.8, 1.2), pantsMat);
                hPants.position.set(0, 1.2, 0.2);
                homer.add(hBody, hHead, hMuzzle, hEyes, hPants);
                homer.position.set(0, 0, 7.2);
                scene.add(homer);

                // --- 4. 粉色小茶几 ---
                const coffeeTable = new THREE.Group();
                const pinkMat = new THREE.MeshStandardMaterial({ color: 0x8C4A6B }); 
                const tableTop = new THREE.Mesh(new THREE.BoxGeometry(4.5, 0.3, 2.5), pinkMat);
                tableTop.position.y = 1.2;
                const legGeo = new THREE.BoxGeometry(0.2, 1.2, 0.2);
                [[ -2, 0.6, -1], [2, 0.6, -1], [-2, 0.6, 1], [2, 0.6, 1]].forEach(pos => {
                    const leg = new THREE.Mesh(legGeo, pinkMat);
                    leg.position.set(...pos);
                    coffeeTable.add(leg);
                });
                coffeeTable.add(tableTop);
                coffeeTable.position.set(0, 0, 2); 
                scene.add(coffeeTable);

                // --- 5. 電視機 ---
                const tvGroup = new THREE.Group();
                const cabinet = new THREE.Mesh(new THREE.BoxGeometry(6, 1.5, 3), new THREE.MeshStandardMaterial({ color: 0x2A1510 }));
                cabinet.position.y = 0.75;
                const tvBox = new THREE.Mesh(new THREE.BoxGeometry(4.5, 3.5, 2.2), new THREE.MeshStandardMaterial({ color: 0x1A331A }));
                tvBox.position.y = 3.2;

                // 螢幕加上雜訊貼圖
                const screen = new THREE.Mesh(
                    new THREE.PlaneGeometry(3.6, 2.6), 
                    new THREE.MeshBasicMaterial({ map: noiseTexture, color: 0xaaaaaa })
                );
                screen.position.set(0, 3.2, 1.11); 
                screen.name = "TV_SCREEN";

                tvGroup.add(cabinet, tvBox, screen);
                tvGroup.position.set(0, 0, -6);
                scene.add(tvGroup);

                // --- 6. 牆面掛畫 ---
                const boatArt = new THREE.Group();
                const frame = new THREE.Mesh(new THREE.BoxGeometry(0.1, 2.5, 3.5), new THREE.MeshStandardMaterial({ color: 0x3D1F09 }));
                const canvasMesh = new THREE.Mesh(new THREE.PlaneGeometry(3.3, 2.3), new THREE.MeshStandardMaterial({ color: 0x224455 }));
                canvasMesh.rotation.y = Math.PI / 2;
                canvasMesh.position.x = 0.06;
                const boatGroup = new THREE.Group();
                const boatBottom = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.4, 1.2), new THREE.MeshBasicMaterial({color: 0x1A0D08}));
                const sail = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1.0, 0.8), new THREE.MeshBasicMaterial({color: 0x888888}));
                sail.position.y = 0.5;
                boatGroup.add(boatBottom, sail);
                boatArt.add(frame, canvasMesh, boatGroup);
                boatArt.position.set(19.9, 6, 2); 
                boatArt.rotation.x = 0.1;
                scene.add(boatArt);

                // 地毯
                const rug = new THREE.Mesh(new THREE.CircleGeometry(5, 32), new THREE.MeshStandardMaterial({ color: 0x1A331A }));
                rug.rotation.x = -Math.PI / 2;
                rug.scale.set(1.5, 1.2, 1);
                rug.position.set(0, 0.02, -1);
                scene.add(rug);

                sceneRef.current = { scene, camera, renderer, screen, tvLight, updateNoise };

                const animate = () => {
                    requestAnimationFrame(animate);
                    // 更新雜訊與閃爍
                    updateNoise();
                    const flicker = Math.sin(Date.now() * 0.05) * 0.2 + 0.8;
                    tvLight.intensity = 2.5 * flicker;
                    
                    renderer.render(scene, camera);
                };
                animate();

                const handleResize = () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                };
                window.addEventListener('resize', handleResize);
                return () => window.removeEventListener('resize', handleResize);
            }, []);

            const triggerZoom = () => {
                if (!sceneRef.current) return;
                const { camera, screen, tvLight } = sceneRef.current;
                setIsZoomed(true);

                const tl = gsap.timeline();
                // 先讓屏幕變亮（帶雜訊）
                tl.to(screen.material.color, { r: 1.5, g: 1.5, b: 1.5, duration: 0.4 });
                tl.to(tvLight, { intensity: 6, duration: 0.4 }, "<");
                // 鏡頭鑽入電視 - 推進到螢幕前
                tl.to(camera.position, {
                    x: 0, 
                    y: 3.2, 
                    z: -4.3,
                    duration: 2.5,
                    ease: "power3.in"
                }, "<0.2");
                // 繼續推進直到進入螢幕（帶雜訊的螢幕）
                tl.to(camera.position, {
                    z: -1.2,
                    duration: 1.0,
                    ease: "power2.in"
                });
                // 屏幕變得更亮，準備切換
                tl.to(screen.material.color, { r: 2, g: 2, b: 2, duration: 0.3 }, "<0.3");
                // 鏡頭完全進入帶雜訊的螢幕時發送完成信號
                tl.call(() => {
                    window.parent && window.parent.postMessage('simpson-finished', '*');
                }, null, ">-0.2");
            };

            return (
                <div className="ui-overlay w-screen h-screen">
                    <AnimatePresence>
                        {!isZoomed && (
                            <motion.div 
                                exit={{ opacity: 0 }}
                                className="absolute inset-0 flex flex-col justify-between p-12 pointer-events-none"
                            >
                                <div className="flex justify-between items-start pointer-events-auto">
                                    <div className="text-3xl font-black italic text-[#FFD90F] stroke-black" style={{WebkitTextStroke: '1px black'}}>PORTFOLIO ENTRANCE</div>
                                    <div className="text-xs font-bold tracking-widest text-zinc-400 uppercase">Entering Digital Space</div>
                                </div>
                                
                                <div className="flex flex-col items-center">
                                    <button 
                                        onClick={triggerZoom}
                                        className="interactive px-12 py-5 bg-[#FFD90F] text-[#5E3023] font-black rounded-full shadow-[0_8px_0_#5E3023] hover:translate-y-1 hover:shadow-[0_4px_0_#5E3023] transition-all uppercase tracking-widest text-sm"
                                    >
                                        ready to start
                                    </button>
                                    <p className="mt-8 text-[10px] font-bold text-zinc-600 tracking-[0.5em] uppercase">Begin Your Journey</p>
                                </div>
                            </motion.div>
                        )}
                    </AnimatePresence>

                    
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
